1.vu3 的优缺点
1）vue3 使用 proxy 进行数据劫持，可以直接监听对象，数组，而非属性（vue2 使用 defineproperty 进行劫持配合观察者模式，优点兼容性好，数组采用修改原生数组方法实现），有多达 13 种拦截方法，,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；在处理大型数据集合有更好的表现
2）vue3 支持碎片化（Fragment），组件中可以有多个根节点
3）vue3 的 proxy 返回的是一个新对象，可以只操作新对象达到⽬的，⽽ Object.defineProperty 只能遍历对象属性
4）es6 新语法兼容性不好不能使用 polyfil 进行兼容（polyfill 主要抚平不同浏览器之间对 js 实现的差异）
5）vue2 是选项式 api，组件逻辑不易于复用和封装，容易出现代码重复；组件逻辑比较分散，对于复杂组件而言，代码量会逐渐增大，维护困难
vue3 是组合式 api（写在 setup 内），一个功能逻辑代码写在一起（包括函数数据，）
===功能逻辑复杂繁多情况下，各个功能逻辑代码组织再一起，便于阅读和维护
===组件逻辑更易于抽象、封装和重用，代码复用性更好；
===逻辑聚合更加明显，提高了代码的可读性和可维护性（逻辑性偏强，功能逻辑（比如数据、watch、方法等）可以写在一块容易查找，后期维护方便）
6）生命周期不同
v3：setup==(breforeCreate+created)
onBeforeMounted
onMounted
onUpdated
onBeforeUpdated
onUnmounted()
onBeforeUnmounted()
7）父子传参不同，新增继承 provited 和 injuct
8）新增顺义特性 teleport 如<teleport to="body"><div>123</div></teleport>
9）vue3 比 vue2 小，一些功能被删除
vue 的状态选项初始化顺序（有先到后）为 props inject methods data computed watch

2.vue3 为什么没有 this
因为在 setup 种并没有绑定实例对象（在源码中直接执行了 setup，并没有 bind 等实例绑定）
this 未指向当前的组件实例，在 setup 被调用之前，data，methods,computed 等都没有被解析，但是组件实例确实在执行 setup 函数之前就已经被创建好了
照理来说通过 new Vue()创建 vue 实例后应该进入 beforeCreate 生命周期，但是 setup 的执行时机是在 beforeCreate 之前的，此时 this 是 undefined

3.为什么舍弃 this.$set，因为 v3 是通过 proxy 代理来劫持的数据，监听的是对象，当对象发生变化，可以被捕获到

4.vue3 如何支持多个根节点
Vue 3 之所以能够支持组件模板具有多个根元素，是因为 Vue 3 在编译器层面上进行了一些改进和优化。
在 Vue 3 中，引入了基于标记片段（Fragment）的编译机制。标记片段是一种特殊的数据结构，可以容纳多个子节点，并没有实际的 DOM 元素。这使得 Vue 3 的编译器能够更好地处理具有多个根元素的组件模板。
在处理具有多个根元素的组件模板时，Vue 3 的编译器会将模板中的每个根级标签（包括自定义组件）都编译为一个单独的标记片段。然后，这些标记片段将作为一个数组，一起创建实际的渲染函数。这样，每个根级标签都能够保留自己的作用域和响应式数据，并且它们可以并行地进行更新。

5.npm 发包
发布时切换为 npm 源
通过版本号判断，执行 npm version patch 可以修改版本号并发布
发布包 npm publish
npm version patch 更新补丁如：1.0.0=》1.0.1
npm version minor 跟新功能，不影响主版本号，如：1.0.0=》1.1.0
npm version major 大更新，破坏模块向后兼容性，如：1.0.0=》2.0.0
添加 tag 区分稳定版测试版
npm publish --tag beta/stable/latest
版本号变更原则：
版本号只升不降，不得在数字前加 0，比如 2.01.2 不允许的；
0.y.z，处于开发阶段的版本；
第一个正式版版本往往命名为 1.0.0；
先行版本必须在补丁版本之后添加，比如 2.3.7-0,0 表示先行版本，和补丁版本用-分隔；
版本的比较依次比较主版本 → 次版本 → 补丁版本 → 先行版本，直到第一个能得出比较结果为止；

    ~ 版本号 ----- 指定主版本号或者次版本号相同
        ~3：3x或3.0.0<=v<4.00
        ~3.1：3.1.x或3.1.0<=v<=4.10
        ~3.1.2: 3.1.2 < v < 3.2.0
        指定的版本范围含有预发布版本，只会匹配和完整版本号相同的预发布版本。
        如~3.1.3-beta.2 匹配 3.1.3-beat.3 不匹配 3.1.4-beat-2
    ^版本号 — 第一个非零 版本号相同
        ^3.1.5  3.1.5 <= v < 4.0.0
        ^0.3.6  0.3.6 <= v < 0.4.0
        ^0.0.2  0.0.2 <= v < 0.0.3
        ^3.x.x  3.0.0 <= v < 4.0.0
        ^4.2.x 4.2.0 <= v < 4.3.0
        npm 安装包时，默认使用 ^ 匹配版本。

6.响应式源码
1.proxy 代理数据
创建一个 reactive 方法
const reactive=(target){
const handler = {
get(target,key,receiver){
let result = Reflect.get(target,key,receiver)
track(target,key)
retrun result
},
set(target,key,value,receiver){
let oldValue= target[key]
let result = Reflect.set(target,key,value,receiver)
if(oldValue!=value){
trigger(target,key)
}
retrun result
}
}
return new Proxy(target,handler)
}
//创建一个 ref 方法
function ref(value) {
const refObject = {
get value() {
track(refObject, 'value'); // **_
return value;
},
set value(newValue) {
value = newValue;
trigger(refObject, 'value'); // _**
},
};
return refObject;
}

        当触发get ，添加目标依赖targetMap（weekMap）,以及依赖关系depsMap(Map),depsMap中根据key添加依赖effect到new Set()
        let targetMap= new WeekMap()
        //添加依赖
        const track = (target,key)=>{
            //获取目标依赖图
            let depsMap = targetMap.get(target)
            if(!depsMap){
               targetMap.set(target, (depsMap = new Map()))
            }
            //获取这个属性的依赖对象
            let dep = depsMap.get(key)
            if(!dep){
                depsMap.set(key,(dep=new Set()))
            }
            //把 effect 添加到依赖中
            dep.add(effect)
        }
        当触发set 更新对象
        const trigger= (target,key)=>{
            let depsMap = targetMap.get(target)
            //检查对象是否有关系
            if(!depsMap)return
            let dep = depsMap.get(key)
            if(dep){
                deps.forEach(effect=>{
                    effect()
                })
            }
        }
        例：let p = {a:0,b:1}
        let t=0
        // 创建全局对象，用来指向this
        class ReactiveEffect {
            private _fn: any
            constructor(fn){
                this._fn = fn
            }
            run(){
                activeEffect = this
                this._fn()
            }
        }
        let activeEffect
        export function effect(fn) {
            // fn
            const _effect = new ReactiveEffect(fn)
            _effect.run()
        }
        effect(funciton(){total=p.a*p.b})

7.computed 和 watch 区别
功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。
是否调用缓存：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。
是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。
computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）
使用场景：computed----当一个属性受多个属性影响的时候，使用 computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用 watch-----搜索框.

8.eventloop 1.宏任务由宿主发起，微任务由 js 发起
常见宏任务（Macrotask）：script
setTimeout
setInterval
I/O
requestAnimationFrame
UI 交互事件
常见微任务（Microtask）：Promise.then(catch/finally)
async/await

9.小程序底层原理
分为编译器和运行时
编译器将.vue 文件编译为不同平台对应的文件，如 js,wsxx 等
运行时则是在终端上将页面路由组件等进行转义
运行时分为基础框架，组件，API

10.webpack 流程
读取配置文件，找到入口文件，根据入口文件递归解析项目中所有依赖关系，使用不同 loader 进行解析，解析完成后使用相应 loader 进行编译，编译过程中 webpack 对这些模块进行处理，如转义，亚索等，编译完成后将所有木块合成一个或多个包，最后输出到指定目录下
11.vite 流程
解析依赖关系：Vite 通过解析入口文件及其依赖关系，构建一个依赖图谱。
按需编译：Vite 会根据需要编译的模块，将其转换为 JavaScript 代码。这是 Vite 的一个关键特性，它只编译当前正在编辑的模块，而不是整个项目。
生成虚拟模块：Vite 会为每个模块生成一个虚拟模块，这些模块包含了模块的转换结果和依赖关系。
启动开发服务器：Vite 会启动一个开发服务器，用于提供虚拟模块和热更新功能。当文件发生变化时，Vite 会重新编译相关模块，并通过 WebSocket 将更新的模块推送给浏览器。
生成生产代码：在生产环境中，Vite 会将所有的虚拟模块转换为真实的 JavaScript 文件，并进行代码压缩和优化。
12.webpack 和 vite 区别
开发环境的速度：Vite 利用浏览器原生支持的模块系统，可以实现快速的冷启动和热更新，因此在开发环境下更快。而 Webpack 在每次修改文件时都需要重新编译整个项目，速度相对较慢。
构建速度：由于 Vite 只编译当前正在编辑的模块，所以在构建速度上比 Webpack 更快。Webpack 需要处理整个项目的依赖关系，因此构建速度相对较慢。
生产环境的打包：在生产环境中，Vite 和 Webpack 都能生成优化后的打包文件。但是 Webpack 更加灵活，可以通过各种插件和配置进行更细粒度的优化。
生态系统：Webpack 拥有更为成熟和庞大的生态系统，有大量的插件和加载器可供选择。而 Vite 相对较新，生态系统相对较小，但也在不断发展壮大。
